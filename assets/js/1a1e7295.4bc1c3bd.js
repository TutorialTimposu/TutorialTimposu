"use strict";(self.webpackChunktimposu=self.webpackChunktimposu||[]).push([[4602],{689:(a,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>d,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"java-collection/map","title":"Java Map","description":"Map adalah struktur data collection yang berisikan mapping antara key dan value.","source":"@site/tutorial/java/java-collection/12-map.md","sourceDirName":"java-collection","slug":"/java-collection/map","permalink":"/java/java-collection/map","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12,"title":"Java Map"},"sidebar":"tutorialSidebar","previous":{"title":"Java Deque","permalink":"/java/java-collection/deque"},"next":{"title":"Immutable Map","permalink":"/java/java-collection/immutable-map"}}');var i=e(4848),s=e(8453);const d={sidebar_position:12,title:"Java Map"},r=void 0,l={},p=[{value:"Hashmap",id:"hashmap",level:2},{value:"LinkedHashMap",id:"linkedhashmap",level:2},{value:"IdentityHashMap",id:"identityhashmap",level:2},{value:"WeakHashMap",id:"weakhashmap",level:2},{value:"EnumMap",id:"enummap",level:2}];function u(a){const n={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...a.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Map"})," adalah struktur data collection yang berisikan mapping antara ",(0,i.jsx)(n.strong,{children:"key"})," dan ",(0,i.jsx)(n.strong,{children:"value"}),".\nKey harus bersifat unik, tidak boleh duplikat, dan satu key cuma boleh mapping ke satu value. ",(0,i.jsx)(n.code,{children:"Map"})," sebenarnya mirip dengan Array, cuma bedanya kalo di Array, key adalah index (integer), sedangkan di Map, key nya bebas kita tentukan sesuai keinginan kita ",(0,i.jsx)(n.code,{children:"Map<K, V>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"Map<Integer, String> student = new HashMap<Integer, String>();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hashmap",children:"Hashmap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"HashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," yang melakukan distribusi key menggunakan ",(0,i.jsx)(n.code,{children:"hashCode()"})," function. Karena HashMap sangat bergantung dengan ",(0,i.jsx)(n.code,{children:"hashCode()"})," method,\njadi pastikan kita harus membuat function hashCode seunik mungkin, karena jika terlalu banyak nilai ",(0,i.jsx)(n.code,{children:"hashCode()"})," yang sama, maka pendistribusian key nya tidak akan optimal sehingga proses get data di ",(0,i.jsx)(n.code,{children:"Map"})," akan semakin lambat. Di ",(0,i.jsx)(n.code,{children:"HashMap"})," pengecekan data duplikat dilakukan dengan menggunakan method ",(0,i.jsx)(n.code,{children:"equals()"})," nya."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.HashMap;\nimport java.util.Map;\n\npublic class DemoHashMap {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMap<Integer, String> student = new HashMap<Integer, String>();\n\t\tstudent.put(1, "Thomas"); // method put dapat digunakan untuk insert dan update data\n\t\tstudent.put(2, "Didin");\n\t\tstudent.put(3, "Abdullah");\n\t\tstudent.put(4, "Rustam");\n\t\t\n\t\tSystem.out.println(student.get(2));\n\t\tSystem.out.println(student.get(4));\n\t\tSystem.out.println(student.get(3));\n\t\tSystem.out.println(student.get(1));\n\t}\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"linkedhashmap",children:"LinkedHashMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"LinkedHashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," dengan menggunakan Double Linked List. Pada ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," data akan disimpan berurutan dalam Linked List sesuai urutan waktu kita menyimpan data. Namun perlu diperhatikan, proses get data di ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," akan semakin lambat,\nkarena harus melakukan iterasi data linked list terlebih dahulu. Gunakan ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," jika memang kita lebih mementingkan iterasi/urutan data Map nya."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class DemoLinkedHashMap {\n\n   public static void main(String[] args) {\n   \t\n   \tMap<String, String> countrys = new LinkedHashMap<>();\n//\t\tMap<String, String> countrys = new HashMap<>(); // Jika menggunakan HashMap data tidak berurut karna menggunakan hash\n   \t\n   \tcountrys.put("id", "Indonesia");\n   \tcountrys.put("jp", "Japan");\n   \tcountrys.put("in", "India");\n   \tcountrys.put("zw", "Zimbabwe");\n   \t\n   \tSet<String> keys = countrys.keySet();\n   \t\n   \tfor (String k : keys) {\n   \t\tSystem.out.println(k);\n   \t}\n   }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"identityhashmap",children:"IdentityHashMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"IdentityHashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," sama seperti ",(0,i.jsx)(n.code,{children:"HashMap"})," Yang membedakan adalah cara pengecekan kesamaan datanya, tidak menggunakan function ",(0,i.jsx)(n.code,{children:"equals"}),", melainkan menggunakan operator ",(0,i.jsx)(n.code,{children:"=="})," (reference equality), artinya data dianggap sama, jika memang lokasi di memory tersebut sama."]}),"\n",(0,i.jsx)(n.p,{children:"Contoh:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.IdentityHashMap;\nimport java.util.Map;\n\npublic class DemoIdentityHashMap {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMap<String, String> person = new IdentityHashMap<String, String>();\n\t\t\n\t\tString firstName = "Ucup";\n\t\tString midleName = "si";\n\t\tString lastName = "Timposu";\n\t\t\n\t\tString name1 = "Ucup si Timposu";\n\t\tString name2 = firstName + " " + midleName + " " + lastName;\n\t\t\n\t\t// Perbedaan menggunakan equals dan reference equality\n\t\tSystem.out.println(name1.equals(name2)); // true\n\t\tSystem.out.println(name1 == name2); // false => merujuk ke reference yang berbeda\n\t\t\n\t\tperson.put("person1", name1);\n\t\tperson.put("person2", name2);\n\t\t\n\t\tSystem.out.println(person.size());\n\t}\n\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"true\nfalse\n2\n"})}),"\n",(0,i.jsx)(n.h2,{id:"weakhashmap",children:"WeakHashMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"WeakHashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," mirip dengan ",(0,i.jsx)(n.code,{children:"HashMap"}),". Yang membedakan adalah ",(0,i.jsx)(n.code,{children:"WeakHashMap"})," menggunakan weak key, dimana jika tidak digunakan lagi maka secara otomatis data di ",(0,i.jsx)(n.code,{children:"WeakHashMap"})," akan dihapus.\nArtinya, jika terjadi ",(0,i.jsx)(n.em,{children:"garbage collection"})," di Java, bisa dimungkinkan data di ",(0,i.jsx)(n.code,{children:"WeakHashMap"})," akan dihapus.\n",(0,i.jsx)(n.code,{children:"WeakHashMap"})," cocok digunakan untuk menyimpan data cache di memory secara sementara."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import java.util.Map;\nimport java.util.WeakHashMap;\n\npublic class DemoWeakHashMap {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMap<Integer, Integer> values = new WeakHashMap<Integer, Integer>();\n\t\t\n\t\tfor (int i = 1; i <= 1_000_000; i ++) {\n\t\t\tvalues.put(i, i);\n\t\t}\n\n\t\tSystem.gc(); // menjalankan gerbage collection java\n\t\t\n\t\tSystem.out.println(values.size()); // values tidak sampai 1.000.000 karena sebagian di hapus WeekHashMap\n\t}\n\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"enummap",children:"EnumMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EnumMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," dimana key nya adalah bertipe Enum. Karena data Enum sudah pasti unik dan tidak boleh ada yang sama, oleh karena itu cocok dijadikan key di ",(0,i.jsx)(n.code,{children:"Map"}),". Algoritma pendistribusian key dioptimalkan untuk Enum,sehingga lebih optimal dibandingkan menggunakan ",(0,i.jsx)(n.code,{children:"hashCode()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.EnumMap;\nimport java.util.Map;\n\npublic class DemoEnumMap {\n\n\tstatic enum Gender {\n\t\tMAN, WOMAN, NOT_DEFINED\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMap<Gender, String> persons = new EnumMap<Gender, String>(Gender.class);\n\t\tpersons.put(Gender.MAN, "Ade");\t\t\n\t\tpersons.put(Gender.WOMAN, "Vivin");\t\t\n\t\tpersons.put(Gender.NOT_DEFINED, "Eben");\n\t\t\n\t\tfor (var key : persons.keySet()) {\n\t\t\tSystem.out.println(persons.get(key));\n\t\t}\n\t}\n}\n'})})]})}function c(a={}){const{wrapper:n}={...(0,s.R)(),...a.components};return n?(0,i.jsx)(n,{...a,children:(0,i.jsx)(u,{...a})}):u(a)}},8453:(a,n,e)=>{e.d(n,{R:()=>d,x:()=>r});var t=e(6540);const i={},s=t.createContext(i);function d(a){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof a?a(n):{...n,...a}}),[n,a])}function r(a){let n;return n=a.disableParentContext?"function"==typeof a.components?a.components(i):a.components||i:d(a.components),t.createElement(s.Provider,{value:n},a.children)}}}]);