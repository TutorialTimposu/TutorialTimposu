"use strict";(self.webpackChunktimposu=self.webpackChunktimposu||[]).push([[4602],{689:(a,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>c,frontMatter:()=>s,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"java-collection/map","title":"Java Map","description":"Map adalah struktur data collection yang berisikan mapping antara key dan value.","source":"@site/tutorial/java/java-collection/12-map.md","sourceDirName":"java-collection","slug":"/java-collection/map","permalink":"/java/java-collection/map","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12,"title":"Java Map"},"sidebar":"tutorialSidebar","previous":{"title":"Java Deque","permalink":"/java/java-collection/deque"},"next":{"title":"Immutable Map","permalink":"/java/java-collection/immutable-map"}}');var i=e(4848),r=e(8453);const s={sidebar_position:12,title:"Java Map"},d=void 0,l={},p=[{value:"Hashmap",id:"hashmap",level:2},{value:"LinkedHashMap",id:"linkedhashmap",level:2},{value:"IdentityHashMap",id:"identityhashmap",level:2},{value:"WeakHashMap",id:"weakhashmap",level:2},{value:"EnumMap",id:"enummap",level:2}];function u(a){const n={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...a.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Map"})," adalah struktur data collection yang berisikan mapping antara ",(0,i.jsx)(n.strong,{children:"key"})," dan ",(0,i.jsx)(n.strong,{children:"value"}),".\r\nKey harus bersifat unik, tidak boleh duplikat, dan satu key cuma boleh mapping ke satu value. ",(0,i.jsx)(n.code,{children:"Map"})," sebenarnya mirip dengan Array, cuma bedanya kalo di Array, key adalah index (integer), sedangkan di Map, key nya bebas kita tentukan sesuai keinginan kita ",(0,i.jsx)(n.code,{children:"Map<K, V>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"Map<Integer, String> student = new HashMap<Integer, String>();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hashmap",children:"Hashmap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"HashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," yang melakukan distribusi key menggunakan ",(0,i.jsx)(n.code,{children:"hashCode()"})," function. Karena HashMap sangat bergantung dengan ",(0,i.jsx)(n.code,{children:"hashCode()"})," method,\r\njadi pastikan kita harus membuat function hashCode seunik mungkin, karena jika terlalu banyak nilai ",(0,i.jsx)(n.code,{children:"hashCode()"})," yang sama, maka pendistribusian key nya tidak akan optimal sehingga proses get data di ",(0,i.jsx)(n.code,{children:"Map"})," akan semakin lambat. Di ",(0,i.jsx)(n.code,{children:"HashMap"})," pengecekan data duplikat dilakukan dengan menggunakan method ",(0,i.jsx)(n.code,{children:"equals()"})," nya."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class DemoHashMap {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\tMap<Integer, String> student = new HashMap<Integer, String>();\r\n\t\tstudent.put(1, "Thomas"); // method put dapat digunakan untuk insert dan update data\r\n\t\tstudent.put(2, "Didin");\r\n\t\tstudent.put(3, "Abdullah");\r\n\t\tstudent.put(4, "Rustam");\r\n\t\t\r\n\t\tSystem.out.println(student.get(2));\r\n\t\tSystem.out.println(student.get(4));\r\n\t\tSystem.out.println(student.get(3));\r\n\t\tSystem.out.println(student.get(1));\r\n\t}\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"linkedhashmap",children:"LinkedHashMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"LinkedHashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," dengan menggunakan Double Linked List. Pada ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," data akan disimpan berurutan dalam Linked List sesuai urutan waktu kita menyimpan data. Namun perlu diperhatikan, proses get data di ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," akan semakin lambat,\r\nkarena harus melakukan iterasi data linked list terlebih dahulu. Gunakan ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," jika memang kita lebih mementingkan iterasi/urutan data Map nya."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.LinkedHashMap;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\npublic class DemoLinkedHashMap {\r\n\r\n   public static void main(String[] args) {\r\n   \t\r\n   \tMap<String, String> countrys = new LinkedHashMap<>();\r\n//\t\tMap<String, String> countrys = new HashMap<>(); // Jika menggunakan HashMap data tidak berurut karna menggunakan hash\r\n   \t\r\n   \tcountrys.put("id", "Indonesia");\r\n   \tcountrys.put("jp", "Japan");\r\n   \tcountrys.put("in", "India");\r\n   \tcountrys.put("zw", "Zimbabwe");\r\n   \t\r\n   \tSet<String> keys = countrys.keySet();\r\n   \t\r\n   \tfor (String k : keys) {\r\n   \t\tSystem.out.println(k);\r\n   \t}\r\n   }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"identityhashmap",children:"IdentityHashMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"IdentityHashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," sama seperti ",(0,i.jsx)(n.code,{children:"HashMap"})," Yang membedakan adalah cara pengecekan kesamaan datanya, tidak menggunakan function ",(0,i.jsx)(n.code,{children:"equals"}),", melainkan menggunakan operator ",(0,i.jsx)(n.code,{children:"=="})," (reference equality), artinya data dianggap sama, jika memang lokasi di memory tersebut sama."]}),"\n",(0,i.jsx)(n.p,{children:"Contoh:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.IdentityHashMap;\r\nimport java.util.Map;\r\n\r\npublic class DemoIdentityHashMap {\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\tMap<String, String> person = new IdentityHashMap<String, String>();\r\n\t\t\r\n\t\tString firstName = "Ucup";\r\n\t\tString midleName = "si";\r\n\t\tString lastName = "Timposu";\r\n\t\t\r\n\t\tString name1 = "Ucup si Timposu";\r\n\t\tString name2 = firstName + " " + midleName + " " + lastName;\r\n\t\t\r\n\t\t// Perbedaan menggunakan equals dan reference equality\r\n\t\tSystem.out.println(name1.equals(name2)); // true\r\n\t\tSystem.out.println(name1 == name2); // false => merujuk ke reference yang berbeda\r\n\t\t\r\n\t\tperson.put("person1", name1);\r\n\t\tperson.put("person2", name2);\r\n\t\t\r\n\t\tSystem.out.println(person.size());\r\n\t}\r\n\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"true\r\nfalse\r\n2\n"})}),"\n",(0,i.jsx)(n.h2,{id:"weakhashmap",children:"WeakHashMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"WeakHashMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," mirip dengan ",(0,i.jsx)(n.code,{children:"HashMap"}),". Yang membedakan adalah ",(0,i.jsx)(n.code,{children:"WeakHashMap"})," menggunakan weak key, dimana jika tidak digunakan lagi maka secara otomatis data di ",(0,i.jsx)(n.code,{children:"WeakHashMap"})," akan dihapus.\r\nArtinya, jika terjadi ",(0,i.jsx)(n.em,{children:"garbage collection"})," di Java, bisa dimungkinkan data di ",(0,i.jsx)(n.code,{children:"WeakHashMap"})," akan dihapus.\r\n",(0,i.jsx)(n.code,{children:"WeakHashMap"})," cocok digunakan untuk menyimpan data cache di memory secara sementara."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import java.util.Map;\r\nimport java.util.WeakHashMap;\r\n\r\npublic class DemoWeakHashMap {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\tMap<Integer, Integer> values = new WeakHashMap<Integer, Integer>();\r\n\t\t\r\n\t\tfor (int i = 1; i <= 1_000_000; i ++) {\r\n\t\t\tvalues.put(i, i);\r\n\t\t}\r\n\r\n\t\tSystem.gc(); // menjalankan gerbage collection java\r\n\t\t\r\n\t\tSystem.out.println(values.size()); // values tidak sampai 1.000.000 karena sebagian di hapus WeekHashMap\r\n\t}\r\n\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"enummap",children:"EnumMap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EnumMap"})," adalah implementasi ",(0,i.jsx)(n.code,{children:"Map"})," dimana key nya adalah bertipe Enum. Karena data Enum sudah pasti unik dan tidak boleh ada yang sama, oleh karena itu cocok dijadikan key di ",(0,i.jsx)(n.code,{children:"Map"}),". Algoritma pendistribusian key dioptimalkan untuk Enum,sehingga lebih optimal dibandingkan menggunakan ",(0,i.jsx)(n.code,{children:"hashCode()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.EnumMap;\r\nimport java.util.Map;\r\n\r\npublic class DemoEnumMap {\r\n\r\n\tstatic enum Gender {\r\n\t\tMAN, WOMAN, NOT_DEFINED\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\t\r\n\t\tMap<Gender, String> persons = new EnumMap<Gender, String>(Gender.class);\r\n\t\tpersons.put(Gender.MAN, "Ade");\t\t\r\n\t\tpersons.put(Gender.WOMAN, "Vivin");\t\t\r\n\t\tpersons.put(Gender.NOT_DEFINED, "Eben");\r\n\t\t\r\n\t\tfor (var key : persons.keySet()) {\r\n\t\t\tSystem.out.println(persons.get(key));\r\n\t\t}\r\n\t}\r\n}\n'})})]})}function c(a={}){const{wrapper:n}={...(0,r.R)(),...a.components};return n?(0,i.jsx)(n,{...a,children:(0,i.jsx)(u,{...a})}):u(a)}},8453:(a,n,e)=>{e.d(n,{R:()=>s,x:()=>d});var t=e(6540);const i={},r=t.createContext(i);function s(a){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof a?a(n):{...n,...a}}),[n,a])}function d(a){let n;return n=a.disableParentContext?"function"==typeof a.components?a.components(i):a.components||i:s(a.components),t.createElement(r.Provider,{value:n},a.children)}}}]);